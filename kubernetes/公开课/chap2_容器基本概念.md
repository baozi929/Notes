# 容器与镜像

1. 操作系统如何管理进程？

   1. 通过 ps 可看到各种进程，包含系统自带的服务进程和用户的应用进程。这些进程：
      - 可以相互看到、相互通信
      - 使用同一文件系统，可对同一文件进行读写
      - 使用相同的系统资源
   2. 上述情况可能带来的问题
      - 进程能够相互看到并且进行通信 -> 高级权限的进程可以攻击其他进程
      - 进程使用同一个文件系统，因此会带来两个问题：
        - 进程可以对已有的数据进行增删改查，具有高级权限的进程可能会将其他进程的数据删除，破坏其他进程的正常运行
        - 进程与进程之间所需的依赖可能会存在冲突，从而给运维带来很大的压力
      - 进程使用的是同一个宿主机的资源，应用之间存在资源抢占问题
   3. 如何为进程提供独立的运行环境？
      - 问题1：不同进程使用同一个文件系统
        - 在 linux 和 unix 操作系统，可使用 **chroot** 将子目录变为根目录，从而达到**视图级别的隔离**；进程在 chroot 的帮助下可以具有独立的文件系统，对于这样的文件系统增删改查不影响其他进程
      - 问题2：进程之间可以相互看见并且相互通信
        - 使用 **Namespace** 技术来实现进程**在资源的视图上进行隔离**。通过 chroot 和 Namespace，可以让进程运行在独立的环境下
      - 问题3：独立运行的环境下，进程所使用的还是同一个 OS 的资源。为减少进程之间的影响，可以通过**cgroup**来**限制其资源使用率**，设置其能使用的 CPU 以及 Memory

2. 什么是容器？

   1. **一个视图隔离、资源可限制、独立文件系统的进程集合**
      - 视图隔离：如能看到部分进程；独立的主机名等
      - 控制资源使用率：如 2G 内存，CPU 使用个数等
   2. 容器特点
      - 容器就是一个进程集合，它将系统的其他资源隔离开来，具有自己独立的资源视图
      - 容器具有一个独立的文件系统，它使用系统的资源，在独立的文件系统中不需要具备内核相关的代码或工具，**只需要提供容器所需的二进制文件、配置文件以及依赖**即可

3. 什么是镜像？

   1. 这些**容器运行时所需要的所有的文件集合**称为容器镜像
   2. 一般使用 Dockerfile 构建镜像
      - Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明
   3. 构建步骤所产生的文件变化，称为 changeset
      - 特点：分层和复用
      - 优势：
        1. 提高分发效率（大的镜像可以拆分，从而并行操作）
        2. 数据共享，不需要重复下载，节约系统资源

4. 如何构建镜像

   1. 例子：构建 golang 应用

      1. 写Dockerfile

         - ```
           # base on golang:1.12-alpine image
           FROM golang:1.12-alpine
           
           # setting current working dir
           WORKDIR /go/src/app
           
           # copy local files into /go/src/app
           COPY . .
           
           # get all the dependencies
           RUN go get -d -v ./...
           
           # build the application and install it
           RUN go install -v ./...
           
           # by default, run the app
           CMD ["app"]
           ```

      2. 通过 docker build 命令构建所需应用（构建的结果在本地）

      3. 如果要将镜像运行到生产或测试环境，需要镜像仓库 docker registry，负责存储所有产生的镜像数据。只需通过 docker push 就能将本地镜像 push 到镜像仓库中，在生产或测试环境只需要将相应数据下载并运行即可

5. 如何运行容器？

   1. 从镜像仓库下载镜像
      1. 例：docker pull busybox:1.25
   2. 查看本地镜像列表：docker images
   3. 选择相应的镜像并运行：docker run [-d] --name demo busybox:1.25 top
      1. 指定容器名、镜像、容器对应进程

6. 小结

   1. **容器：和系统其它部分隔离开来的进程集合**
   2. **镜像：容器所需要的所有文件集合，其具备一次构建、到处运行的特点**



# 容器的生命周期

1. initial进程

   - 在使用 docker run 的时候会选择一个镜像来提供独立的文件系统并指定相应的运行程序。这里指定的运行程序称之为 initial 进程
   - initial 进程生命周期 = 容器生命周期

2. 其他进程

   - initial 进程产生的子进程，或通过 docker exec 产生的运维操作
   - initial进程退出时，所有子进程也会退出 -> 存在的问题：可能导致数据丢失 -> 需要持久化容器产生的重要数据

3. 数据持久化

   - 容器能够直接将数据持久化到指定的目录上，这个目录就称之为**数据卷**

   - 数据卷的生命周期独立于容器的生命周期

   - 数据卷的管理方式：

     - 宿主机上的目录直接mount到容器内

       - 例：

         - ```
           docker run -v /tmp:/tmp busybox:1.25 sh -c "date > /tmp/demo.log"
           ```

       - -v 后的参数，左边为宿主机目录，右边为容器内目录

       - 该方法特点：方法简单，但会带来运维成本（依赖宿主机目录，需要对所有宿主机统一管理）

     - 将目录管理交给运行引擎

       - 例：

         - ```
           docker create volume demo
           docker run -v demo:/tmp busybox:1.25 sh -c "date > /tmp/demo.log"
           ```



# 容器项目架构

1. moby 容器引擎架构



# 容器 VS VM

1. VM
   - 利用 Hypervisor 虚拟化技术来模拟 CPU、内存等硬件资源，这样就可以在宿主机上建立一个 Guest OS
   - 每一个 Guest OS 都有一个独立的内核，比如 Ubuntu、CentOS、 Windows 等
   - 特点：
     - 优点
       - 每个应用都是相互独立的，VM 可以提供更好的隔离效果
     - 代价：
       - 因为需要把一部分的计算资源交给虚拟化，这样就很难充分利用现有的计算资源
       - 每个 Guest OS 都需要占用大量的磁盘空间
       - 启动很慢
2. 容器
   1. 容器是针对进程而言的，无需 Guest OS，只需要一个独立的文件系统提供其所需要文件集合即可
   2. 特点：
      - 文件的隔离是进程级别的，启动时间快于VM，所需磁盘空间也小于VM
      - 隔离效果比 VM 差很多
   3. 容器技术在向着强隔离方向发展